"""
Node management routes for Agent communication.
"""

import secrets
from datetime import datetime
from typing import Annotated, Optional

from fastapi import APIRouter, Depends, HTTPException, Header, status
from fastapi.responses import PlainTextResponse
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from brain.config import get_settings
from brain.models.base import get_db
from brain.models.node import Node
from brain.models.provider import Provider
from shared.schemas import (
    NodeRegistrationRequest,
    NodeRegistrationResponse,
    NodeHeartbeatRequest,
    NodeHeartbeatResponse,
    NodeStatus,
    GpuInfo,
    ProviderType,
)

router = APIRouter(prefix="/nodes", tags=["Nodes"])
settings = get_settings()


def escape_like(value: str) -> str:
    """Escape special LIKE pattern characters to prevent SQL injection."""
    return value.replace("\\", "\\\\").replace("%", "\\%").replace("_", "\\_")


# Agent install script template
INSTALL_SCRIPT_TEMPLATE = '''#!/bin/bash
# GPU Agent Install Script
# Generated by GPU Cloud Orchestrator Brain
#
# Usage:
#   For cloud providers (auto-provisioned):
#     curl -sSL https://brain-url/api/v1/nodes/install.sh | bash -s -- --auto
#
#   For community providers (Phase 2):
#     curl -sSL https://brain-url/api/v1/nodes/install.sh | bash -s -- --provider-key=pk_xxxx
#
set -e

BRAIN_URL="${{BRAIN_URL:-{brain_url}}}"
PROVIDER_TYPE="${{PROVIDER_TYPE:-community}}"
PROVIDER_INSTANCE_ID="${{PROVIDER_INSTANCE_ID:-}}"
PROVIDER_KEY="${{PROVIDER_KEY:-}}"
HOURLY_PRICE="${{HOURLY_PRICE:-}}"
AUTO_MODE=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --auto) AUTO_MODE=true; shift ;;
        --brain-url) BRAIN_URL="$2"; shift 2 ;;
        --brain-url=*) BRAIN_URL="${{1#*=}}"; shift ;;
        --provider-type) PROVIDER_TYPE="$2"; shift 2 ;;
        --provider-type=*) PROVIDER_TYPE="${{1#*=}}"; shift ;;
        --provider-id) PROVIDER_INSTANCE_ID="$2"; shift 2 ;;
        --provider-id=*) PROVIDER_INSTANCE_ID="${{1#*=}}"; shift ;;
        --provider-key) PROVIDER_KEY="$2"; shift 2 ;;
        --provider-key=*) PROVIDER_KEY="${{1#*=}}"; shift ;;
        --hourly-price) HOURLY_PRICE="$2"; shift 2 ;;
        --hourly-price=*) HOURLY_PRICE="${{1#*=}}"; shift ;;
        *) shift ;;
    esac
done

echo "=================================="
echo "GPU Agent Installation"
echo "=================================="
echo "Brain URL: $BRAIN_URL"
echo "Provider Type: $PROVIDER_TYPE"
if [ -n "$PROVIDER_KEY" ]; then
    echo "Provider Key: ${{PROVIDER_KEY:0:10}}..."
fi
if [ -n "$PROVIDER_INSTANCE_ID" ]; then
    echo "Instance ID: $PROVIDER_INSTANCE_ID"
fi
if [ -n "$HOURLY_PRICE" ]; then
    echo "Hourly Price: \\$$HOURLY_PRICE"
fi
echo ""

# Check for NVIDIA GPU
echo "Checking for NVIDIA GPU..."
if ! command -v nvidia-smi &> /dev/null; then
    echo "WARNING: nvidia-smi not found. GPU detection may fail."
else
    nvidia-smi --query-gpu=name,memory.total --format=csv,noheader
    echo "GPU detected!"
fi

# Check for Docker
echo "Checking for Docker..."
if ! command -v docker &> /dev/null; then
    echo "ERROR: Docker is required but not installed."
    echo "Install Docker first: curl -fsSL https://get.docker.com | sh"
    exit 1
fi
docker --version
echo "Docker is installed!"

# Create agent directory
AGENT_DIR="/opt/gpu-agent"
mkdir -p "$AGENT_DIR"
cd "$AGENT_DIR"

# Create virtual environment
echo "Setting up Python environment..."
if ! command -v python3 &> /dev/null; then
    echo "ERROR: Python 3 is required but not installed."
    exit 1
fi
python3 -m venv venv
source venv/bin/activate

# Install agent
echo "Installing GPU Agent..."
pip install --quiet --upgrade pip
pip install --quiet httpx pydantic pydantic-settings docker

# Download agent code (in production, this would be a pip package or git clone)
# For now, create a minimal agent that registers and sends heartbeats

cat > agent_runner.py << 'AGENT_EOF'
import asyncio
import json
import os
import socket
import subprocess
from pathlib import Path

import httpx

BRAIN_URL = os.environ.get("BRAIN_URL", "{brain_url}")
PROVIDER_TYPE = os.environ.get("PROVIDER_TYPE", "community")
PROVIDER_INSTANCE_ID = os.environ.get("PROVIDER_INSTANCE_ID", "")
PROVIDER_KEY = os.environ.get("PROVIDER_KEY", "")
HOURLY_PRICE = os.environ.get("HOURLY_PRICE", "")
CONFIG_FILE = Path("/opt/gpu-agent/config.json")

def detect_gpus():
    """Detect GPUs using nvidia-smi."""
    gpus = []
    try:
        result = subprocess.run(
            ["nvidia-smi", "--query-gpu=index,name,memory.total,temperature.gpu,utilization.gpu",
             "--format=csv,noheader,nounits"],
            capture_output=True, text=True
        )
        for line in result.stdout.strip().split("\\n"):
            if line:
                parts = [p.strip() for p in line.split(",")]
                gpus.append({{
                    "index": int(parts[0]),
                    "name": parts[1],
                    "memory_total_mb": int(parts[2]),
                    "memory_used_mb": 0,
                    "memory_free_mb": int(parts[2]),
                    "temperature_c": int(parts[3]) if parts[3] != "[N/A]" else None,
                    "utilization_percent": int(parts[4]) if parts[4] != "[N/A]" else None,
                }})
    except Exception as e:
        print(f"GPU detection failed: {{e}}")
    return gpus

def get_system_info():
    """Get system information."""
    import platform
    return {{
        "hostname": socket.gethostname(),
        "os_name": f"{{platform.system()}} {{platform.release()}}",
        "kernel_version": platform.release(),
        "cpu_model": platform.processor() or "Unknown",
        "cpu_cores": os.cpu_count() or 1,
        "ram_total_mb": 0,
        "ram_available_mb": 0,
        "disk_total_gb": 0,
        "disk_available_gb": 0,
    }}

def get_public_ip():
    """Get public IP address."""
    try:
        import urllib.request
        return urllib.request.urlopen("https://api.ipify.org", timeout=5).read().decode()
    except Exception:
        return None

async def register():
    """Register with the Brain."""
    gpus = detect_gpus()
    system_info = get_system_info()
    ip_address = socket.gethostbyname(socket.gethostname())
    public_ip = get_public_ip()

    request = {{
        "hostname": system_info["hostname"],
        "ip_address": ip_address,
        "public_ip": public_ip,
        "gpus": gpus,
        "system_info": system_info,
        "agent_version": "0.2.0",
        "provider_type": PROVIDER_TYPE,
        "provider_id": PROVIDER_INSTANCE_ID if PROVIDER_INSTANCE_ID else None,
        "provider_key": PROVIDER_KEY if PROVIDER_KEY else None,
        "hourly_price": float(HOURLY_PRICE) if HOURLY_PRICE else None,
    }}

    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{{BRAIN_URL}}/api/v1/nodes/register",
            json=request,
            timeout=30.0
        )
        response.raise_for_status()
        return response.json()

async def main():
    print("Registering with Brain...")
    try:
        result = await register()
        print(f"\\n✓ Registration successful!")
        print(f"  Node ID: {{result['node_id']}}")
        print(f"  Message: {{result['message']}}")

        # Save config
        CONFIG_FILE.write_text(json.dumps({{
            "node_id": result["node_id"],
            "api_key": result["api_key"],
            "brain_url": BRAIN_URL,
            "heartbeat_interval": result["heartbeat_interval_seconds"],
        }}, indent=2))

        print(f"\\nConfig saved to: {{CONFIG_FILE}}")
        print("\\nFor full agent functionality, install the complete agent package.")
    except httpx.HTTPStatusError as e:
        print(f"\\n✗ Registration failed: {{e.response.status_code}}")
        try:
            error = e.response.json()
            print(f"  Error: {{error.get('detail', 'Unknown error')}}")
        except Exception:
            print(f"  Response: {{e.response.text}}")
        raise SystemExit(1)
    except Exception as e:
        print(f"\\n✗ Registration failed: {{e}}")
        raise SystemExit(1)

if __name__ == "__main__":
    asyncio.run(main())
AGENT_EOF

# Set environment and run
export BRAIN_URL="$BRAIN_URL"
export PROVIDER_TYPE="$PROVIDER_TYPE"
export PROVIDER_INSTANCE_ID="$PROVIDER_INSTANCE_ID"
export PROVIDER_KEY="$PROVIDER_KEY"
export HOURLY_PRICE="$HOURLY_PRICE"

echo ""
echo "Running agent registration..."
python agent_runner.py

echo ""
echo "=================================="
echo "Installation Complete!"
echo "=================================="
echo ""
echo "Next steps:"
echo "  1. Start the agent: systemctl start gpu-agent"
echo "  2. Enable auto-start: systemctl enable gpu-agent"
echo "  3. View logs: journalctl -u gpu-agent -f"
echo ""
'''


def generate_agent_api_key() -> str:
    """Generate a secure API key for an agent."""
    return f"{settings.agent_api_key_prefix}{secrets.token_urlsafe(32)}"


async def verify_agent_api_key(
    x_agent_api_key: Annotated[Optional[str], Header()] = None,
    db: AsyncSession = Depends(get_db),
) -> Optional[Node]:
    """Verify agent API key and return the associated node."""
    if not x_agent_api_key:
        return None

    result = await db.execute(
        select(Node).where(Node.agent_api_key == x_agent_api_key)
    )
    return result.scalar_one_or_none()


async def require_agent_api_key(
    node: Annotated[Optional[Node], Depends(verify_agent_api_key)],
) -> Node:
    """Require valid agent API key."""
    if not node:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or missing agent API key",
        )
    return node


@router.post("/register", response_model=NodeRegistrationResponse)
async def register_node(
    request: NodeRegistrationRequest,
    db: Annotated[AsyncSession, Depends(get_db)],
) -> dict:
    """
    Register a new GPU node with the Brain.
    Called by Agent on first startup.

    If a provider_key is provided, the node will be linked to the provider's account.
    """
    # Validate provider key if provided (Phase 2: Community providers)
    provider: Optional[Provider] = None
    if request.provider_key:
        result = await db.execute(
            select(Provider).where(Provider.provider_key == request.provider_key)
        )
        provider = result.scalar_one_or_none()

        if not provider:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid provider key",
            )
        if not provider.is_active or provider.is_suspended:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Provider account is not active",
            )

    # Check if node already exists by IP
    result = await db.execute(
        select(Node).where(Node.ip_address == request.ip_address)
    )
    existing_node = result.scalar_one_or_none()

    if existing_node:
        # Update existing node
        existing_node.hostname = request.hostname
        existing_node.gpu_model = request.gpus[0].name if request.gpus else "Unknown"
        existing_node.gpu_count = len(request.gpus)
        existing_node.total_vram_mb = sum(g.memory_total_mb for g in request.gpus)
        existing_node.gpu_details = [g.model_dump() for g in request.gpus]
        existing_node.cpu_model = request.system_info.cpu_model
        existing_node.cpu_cores = request.system_info.cpu_cores
        existing_node.ram_total_mb = request.system_info.ram_total_mb
        existing_node.disk_total_gb = request.system_info.disk_total_gb
        existing_node.os_info = request.system_info.os_name
        existing_node.agent_version = request.agent_version
        existing_node.status = NodeStatus.ONLINE
        existing_node.last_heartbeat_at = datetime.utcnow()
        existing_node.consecutive_missed_heartbeats = 0

        if request.hourly_price is not None:
            existing_node.hourly_price = request.hourly_price

        # Link to provider if provided
        if provider:
            existing_node.provider_user_id = provider.id
            existing_node.owner_user_id = provider.user_id
            existing_node.provider_type = ProviderType.COMMUNITY

        await db.flush()

        return {
            "node_id": existing_node.id,
            "api_key": existing_node.agent_api_key,
            "heartbeat_interval_seconds": settings.heartbeat_interval_seconds,
            "message": "Node re-registered successfully" + (
                f" (linked to provider: {provider.display_name})" if provider else ""
            ),
        }

    # Create new node
    api_key = generate_agent_api_key()
    primary_gpu = request.gpus[0] if request.gpus else None

    node = Node(
        hostname=request.hostname,
        ip_address=request.ip_address,
        public_ip=request.public_ip,
        gpu_model=primary_gpu.name if primary_gpu else "Unknown",
        gpu_count=len(request.gpus),
        total_vram_mb=sum(g.memory_total_mb for g in request.gpus),
        gpu_details=[g.model_dump() for g in request.gpus],
        cpu_model=request.system_info.cpu_model,
        cpu_cores=request.system_info.cpu_cores,
        ram_total_mb=request.system_info.ram_total_mb,
        disk_total_gb=request.system_info.disk_total_gb,
        os_info=request.system_info.os_name,
        agent_version=request.agent_version,
        agent_api_key=api_key,
        provider_type=ProviderType.COMMUNITY if provider else request.provider_type,
        provider_id=request.provider_id,
        hourly_price=request.hourly_price or 0.0,
        status=NodeStatus.ONLINE,
        last_heartbeat_at=datetime.utcnow(),
        # Link to provider if provided
        provider_user_id=provider.id if provider else None,
        owner_user_id=provider.user_id if provider else None,
    )

    db.add(node)
    await db.flush()
    await db.refresh(node)

    return {
        "node_id": node.id,
        "api_key": api_key,
        "heartbeat_interval_seconds": settings.heartbeat_interval_seconds,
        "message": "Node registered successfully" + (
            f" (linked to provider: {provider.display_name})" if provider else ""
        ),
    }


@router.post("/heartbeat", response_model=NodeHeartbeatResponse)
async def node_heartbeat(
    request: NodeHeartbeatRequest,
    node: Annotated[Node, Depends(require_agent_api_key)],
    db: Annotated[AsyncSession, Depends(get_db)],
) -> dict:
    """
    Receive heartbeat from agent.
    Updates node status and returns any pending commands.
    """
    # Verify node ID matches
    if str(node.id) != str(request.node_id):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Node ID mismatch",
        )

    # Update node status
    node.status = NodeStatus.ONLINE
    node.last_heartbeat_at = datetime.utcnow()
    node.consecutive_missed_heartbeats = 0

    # Update GPU metrics
    if request.gpus:
        primary_gpu = request.gpus[0]
        node.current_gpu_utilization = primary_gpu.utilization_percent
        node.current_vram_used_mb = primary_gpu.memory_used_mb
        node.current_temperature_c = primary_gpu.temperature_c
        node.gpu_details = [g.model_dump() for g in request.gpus]

    # Update system info
    node.ram_total_mb = request.system_info.ram_total_mb

    # Update pod count
    node.current_pod_count = len(request.running_pods)

    await db.flush()

    # TODO: Check for pending commands (pod deployments, stops, etc.)
    commands = []

    return {
        "acknowledged": True,
        "commands": commands,
    }


@router.get("/")
async def list_nodes(
    db: Annotated[AsyncSession, Depends(get_db)],
    status: Optional[NodeStatus] = None,
    gpu_model: Optional[str] = None,
) -> list[dict]:
    """List all registered nodes (admin endpoint)."""
    query = select(Node)

    if status:
        query = query.where(Node.status == status)
    if gpu_model:
        escaped_model = escape_like(gpu_model)
        query = query.where(Node.gpu_model.ilike(f"%{escaped_model}%"))

    result = await db.execute(query)
    nodes = result.scalars().all()

    return [
        {
            "id": node.id,
            "hostname": node.hostname,
            "gpu_model": node.gpu_model,
            "gpu_count": node.gpu_count,
            "total_vram_mb": node.total_vram_mb,
            "status": node.status.value,
            "hourly_price": node.hourly_price,
            "current_pod_count": node.current_pod_count,
            "max_pods": node.max_pods,
            "last_heartbeat_at": node.last_heartbeat_at.isoformat() if node.last_heartbeat_at else None,
        }
        for node in nodes
    ]


@router.get("/available")
async def list_available_nodes(
    db: Annotated[AsyncSession, Depends(get_db)],
    gpu_type: Optional[str] = None,
    min_vram_mb: Optional[int] = None,
    max_price: Optional[float] = None,
) -> list[dict]:
    """List available nodes for pod deployment."""
    query = select(Node).where(Node.status == NodeStatus.ONLINE)

    if gpu_type:
        escaped_type = escape_like(gpu_type)
        query = query.where(Node.gpu_model.ilike(f"%{escaped_type}%"))
    if min_vram_mb:
        query = query.where(Node.total_vram_mb >= min_vram_mb)
    if max_price:
        query = query.where(Node.hourly_price <= max_price)

    result = await db.execute(query)
    nodes = result.scalars().all()

    # Filter to only available nodes
    available = [n for n in nodes if n.is_available]

    return [
        {
            "id": node.id,
            "gpu_model": node.gpu_model,
            "gpu_count": node.gpu_count,
            "total_vram_mb": node.total_vram_mb,
            "available_vram_mb": node.available_vram_mb,
            "hourly_price": node.hourly_price,
            "provider_type": node.provider_type.value,
        }
        for node in available
    ]


@router.get("/install.sh", response_class=PlainTextResponse)
async def get_install_script() -> str:
    """
    Get the agent installation script.

    Returns a bash script that can be piped to bash to install the agent:
    curl -sSL http://brain-url/api/v1/nodes/install.sh | bash -s -- --auto
    """
    brain_url = settings.brain_public_url.rstrip("/")
    return INSTALL_SCRIPT_TEMPLATE.format(brain_url=brain_url)
